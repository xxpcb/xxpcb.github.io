<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>FreeRTOS源码探析之--任务调度相关 | 码农爱学习的博客</title><meta name="keywords" content="FreeRTOS"><meta name="author" content="xxpcb"><meta name="copyright" content="xxpcb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="FreeRTOS可以运行多任务，在于其内核的任务调度功能，本篇介绍任务调度的基本思路与部分源码分析。">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS源码探析之--任务调度相关">
<meta property="og:url" content="http://xxpcb.gitee.io/2021/05/03/FreeRTOS%E6%BA%90%E7%A0%81%E6%8E%A2%E6%9E%90%E4%B9%8B-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="码农爱学习的博客">
<meta property="og:description" content="FreeRTOS可以运行多任务，在于其内核的任务调度功能，本篇介绍任务调度的基本思路与部分源码分析。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xxpcb.gitee.io/img/default-cover.png">
<meta property="article:published_time" content="2021-05-03T04:26:49.000Z">
<meta property="article:modified_time" content="2021-05-03T04:28:17.836Z">
<meta property="article:author" content="xxpcb">
<meta property="article:tag" content="FreeRTOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xxpcb.gitee.io/img/default-cover.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://xxpcb.gitee.io/2021/05/03/FreeRTOS%E6%BA%90%E7%A0%81%E6%8E%A2%E6%9E%90%E4%B9%8B-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//s4.cnzz.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f9c11fefaddf7b7687633a168777f8d9"; //- "https://hm.baidu.com/hm.js?true";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">document.write(unescape("%3Cspan style='display:none;' id='cnzz_stat_icon_1277776467'%3E%3C/span%3E%3Cscript src='https://s23.cnzz.com/z_stat.php%3Fid%3D1277776467%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FreeRTOS源码探析之--任务调度相关',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-03 12:28:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">141</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default-cover.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">码农爱学习的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">FreeRTOS源码探析之--任务调度相关</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-03T04:26:49.000Z" title="发表于 2021-05-03 12:26:49">2021-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-03T04:28:17.836Z" title="更新于 2021-05-03 12:28:17">2021-05-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/FreeRTOS/">FreeRTOS</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>FreeRTOS可以运行多任务，在于其内核的任务调度功能，本篇介绍任务调度的基本思路与部分源码分析。</p>
<span id="more"></span>

<h1 id="1-裸机编程与RTOS-的区别"><a href="#1-裸机编程与RTOS-的区别" class="headerlink" title="1 裸机编程与RTOS 的区别"></a>1 裸机编程与RTOS 的区别</h1><h2 id="1-1-裸机程序基本框架"><a href="#1-1-裸机程序基本框架" class="headerlink" title="1.1 裸机程序基本框架"></a>1.1 裸机程序基本框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();<span class="comment">//一些初始化</span></span><br><span class="line">    <span class="comment">/*死循环*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        do_something_1();<span class="comment">//执行一些逻辑</span></span><br><span class="line">        do_something_2();</span><br><span class="line">    &#125;<span class="comment">//循环执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断服务函数*/</span></span><br><span class="line">IRQ_Handler()</span><br><span class="line">&#123;</span><br><span class="line">    set_flag();<span class="comment">//简短的标记操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单片机裸机编程的思路比较简单，就是一个死循环，程序依次执行while(1)中的各条语句，循环往复即可，需要处理某些紧急事件时，通过中断服务函数来打断while(1)的执行。</p>
<p>裸机编程虽然简单，但只能在一个循环中执行各种裸机，第一项功能执行完后才能执行第二项功能，<strong>就好比有多个人在轮流干活</strong>，CPU的利用率不高，不能处理并行逻辑。</p>
<h2 id="1-2-RTOS程序基本框架"><a href="#1-2-RTOS程序基本框架" class="headerlink" title="1.2 RTOS程序基本框架"></a>1.2 RTOS程序基本框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();<span class="comment">//一些初始化</span></span><br><span class="line">    xTaskCreate();</span><br><span class="line">    vTaskStartScheduler(); <span class="comment">//启动调度器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子任务1（死循环）*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        do_something_1();<span class="comment">//执行一些逻辑(如采集传感器信息)</span></span><br><span class="line">        vTaskDelay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子任务2（死循环）*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        do_something_2();<span class="comment">//执行一些逻辑(如执行电机运动)</span></span><br><span class="line">        vTaskDelay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断服务函数*/</span></span><br><span class="line">IRQ_Handler()</span><br><span class="line">&#123;</span><br><span class="line">    set_event();<span class="comment">//触发事件、信号量等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单片机引入RTOS，可以将各个功能模块分别设计为单独的<strong>任务</strong>，每个任务都是一个死循环，<strong>就好比有多个人在同时干活</strong>，这样CPU的利用率就提高了，并且可以处理一些并行逻辑。</p>
<p>单片机只有一个CPU（核），那怎么让多个人同时干活呢？其实每个子任务虽然都是死循环，但并不是每个子任务一直都在执行，每个子任务在执行期间，可能需要延时，也可能需要等另一个任务的数据到来，所有，<strong>在某个任务在等待的时候，CPU就可以停止此任务，然后切换到其它任务执行，这样看起来就是多个人在同时干活了</strong>。</p>
<h1 id="2-RTOS任务间通信"><a href="#2-RTOS任务间通信" class="headerlink" title="2 RTOS任务间通信"></a>2 RTOS任务间通信</h1><p>在裸机编程中，当设计了一个稍微复杂的功能是，会设计处许多子函数来实现一个整体功能，这之中通知会用到一些<strong>全局变量</strong>或<strong>全局数组</strong>等来实现各个子函数之间的联系。</p>
<p>在RTOS中，当然也可以使用全局变量，但RTOS更推荐我们使用系统自带的<strong>任务间通信机制</strong>。原因有二：</p>
<ol>
<li><p><strong>阻塞等待机制比轮询等待更高效</strong> </p>
<p>全局变量当用作某种事件标志时，获取该标志的任务需要轮询检测标志是否变化，这样会产生大量无效的判断，而使用任务间通信中的阻塞等待机制，CPU可以转而处理其它事情，当标志变化时，解除阻塞，又可以及时执行后续处理。</p>
</li>
<li><p><strong>全局变量会产生不可重入函数造成逻辑混乱</strong> </p>
<p>RTOS运行时，CPU是在各个任务间跳来跳去的，若使用全局变量不恰当，会导致原本设计的逻辑产生混乱。比如某个<strong>低优先级</strong>任务正在访问某个公共函数，并对该函数中的全局变量进行了修改，还未退出该函数时，<strong>更高优先级</strong>的任务抢占了CPU的使用权，并也对该函数中的全局变量进行了修改，此时，如果低优先级的任务若认为自己对变量修改成功，并因此而执行自己后续的逻辑，则会导致逻辑错误。</p>
</li>
</ol>
<p><strong>FreeRTOS任务间通信方式</strong></p>
<ul>
<li><code>信号量</code>(Semaphore)：用于任务间的<strong>同步</strong>，一个任务<strong>以阻塞方式等待</strong>另一个任务<strong>等待另一个</strong>任务释放信号量。</li>
<li><code>互斥量</code>(Mutex)：用于任务间共享资源的<strong>互斥访问</strong>，使用前获取锁，使用后释放锁。</li>
<li><code>事件标志组</code>（EventGroup)：也是用于任务间的<strong>同步</strong>，相比信号量，事件标志组可以<strong>等待多个</strong>事件发生。</li>
<li><code>消息队列</code>(Queue)：类比全局数据，它可以一次发送多个数据（一般将数据定义成结构体发送），每次数据的大小固定不变。</li>
<li><code>流缓冲区</code>(StreamBuffer)：在队列的基础上，优化的一种更适合的数据结构，可以一次写入任意数量的字节，并且可以一次读取任意数量的字节。</li>
<li><code>消息缓冲区</code>(MessageBuffer)：在流式缓冲区的基础上实现的，其进一步针对“消息”进行设计改进，每一条消息的写入增加了一个字节用来表示该条消息的长度，读取时需要一次性读出至少一条消息，否则会返回 0。</li>
<li><code>任务通知</code>(Notify)：不同于上面的任务间通信方式（使用某种<strong>通信对象</strong>，通信对象是独立于任务的实体，有单独的存储空间，可以实现数据传递和较复杂的同步、互斥功能），<strong>通知是发向一个指定的任务的，直接改变该任务TCB的某些变量</strong>。</li>
</ul>
<h1 id="3-RTOS任务调度"><a href="#3-RTOS任务调度" class="headerlink" title="3 RTOS任务调度"></a>3 RTOS任务调度</h1><h2 id="3-1-任务状态"><a href="#3-1-任务状态" class="headerlink" title="3.1 任务状态"></a>3.1 任务状态</h2><p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic/FreeRTOS/scheduler/scheduler-1.png"></p>
<ul>
<li>1 <code>创建任务→就绪态</code>（Ready）：<strong>任务创建完成后</strong>进入就绪态，表明任务已准备就绪，随时可以运行，只等待调度器进行调度。</li>
<li>2 <code>就绪态→运行态</code>（Running）：发生<strong>任务切换时，就绪列表中最高优先级的任务被执行</strong>，从而进入运行态。</li>
<li>3 <code>运行态→就绪态</code>：有更高优先级任务创建或者恢复后，会发生任务调度，此刻就绪列表中<strong>最高优先级任务变为运行态，那么原先运行的任务由运行态变为就绪态</strong>，依然在就绪列表中，等待最高优先级的任务运行完毕继续运行原来的任务。</li>
<li>4 <code>运行态→阻塞态</code>（Blocked）：<strong>正在运行的任务发生阻塞（挂起、延时、读信号量等待）</strong>时，该任务会从就绪列表中删除，任务状态由运行态变成阻塞态，然后发生任务切换，运行就绪列表中当前最高优先级任务。</li>
<li>5 <code>阻塞态→就绪态</code>：<strong>阻塞的任务被恢复</strong>后（任务恢复、延时时间超时、读信号量超时或读到信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变成就绪态；如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。</li>
<li>6、7、8 <code>就绪态、阻塞态、运行态→挂起态</code>（Suspended）：任务可以通过**调用vTaskSuspend() **API 函数都可以将处于任何状态的任务挂起，被挂起的任务得不到CPU的使用权，也不会参与调度，除非它从挂起态中解除。</li>
<li>9 <code>挂起态→就绪态</code>：把 一 个 挂 起 状态 的 任 务 恢复的 唯 一 途 径 就 是 **调 用 vTaskResume() 或vTaskResumeFromISR() **API 函数，如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。</li>
</ul>
<blockquote>
<p>以上是任务运行的各种状态，看起来有点复杂，可以这样理解：</p>
<p>为简单起见，先不考虑挂起态，在任一时刻，CPU只能处理某一个任务，则该任务就处于<strong>运行态</strong>，对于其它任 务，当是自己想要延时或等待时，则处于<strong>阻塞态</strong>，当自己想要执行但因为优先级低而不能执行时，则处于<strong>就绪态</strong>。</p>
<p>然后，以上状态如何被改变呢？</p>
<p>1.运行态的自己想进入阻塞态，则就绪态的任务即可运行。</p>
<p>2.阻塞态的解除阻塞进入就绪，若该任务的优先级更高，则可抢占当前处于运行的任务，使自己运行，使对方就绪。</p>
</blockquote>
<p>有没有发现，阻塞态的任务要想运行，必须先进入就绪态，再进入运行态。</p>
<h2 id="3-2-调度器"><a href="#3-2-调度器" class="headerlink" title="3.2 调度器"></a>3.2 调度器</h2><p>FreeRTOS中提供的任务调度器是基于优先级的<strong>抢占式调度</strong>：在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的。</p>
<p>调度器就是使用相关的调度算法来<strong>决定当前需要执行的任务</strong>。所有的调度器有一些共同的特性：</p>
<ul>
<li>调度器可以区分<strong>就绪态</strong>任务和<strong>挂起态</strong>任务（由于延迟，信号量等待，事件组等待等原因而使得任务被挂起）。</li>
<li>调度器可以选择<strong>就绪态</strong>中的一个任务，然后激活它（通过执行这个任务）。 当前正在执行的任务是<strong>运行态</strong>的任务。</li>
</ul>
<p>FreeRTOS 主要有两种调度方式</p>
<ul>
<li>抢占式调度：每个任务都有不同的优先级，任务会一直运行直到被高优先级任务抢占或者遇到阻塞式的 API 函数，如 vTaskDelay。</li>
<li>时间片调度：每个任务都有相同的优先级，任务会运行固定的时间片个数或者遇到阻塞式的 API 函数，比如vTaskDelay，才会执行同优先级任务之间的任务切换。</li>
</ul>
<h3 id="3-2-1-抢占式调度示例"><a href="#3-2-1-抢占式调度示例" class="headerlink" title="3.2.1 抢占式调度示例"></a>3.2.1 抢占式调度示例</h3><p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic/FreeRTOS/scheduler/scheduler-2.png"></p>
<ul>
<li><p>创建 3 个任务 Task1，Task2 和 Task3，优先级依次为1、2、3，即Task3的优先级最高。</p>
</li>
<li><p>起初任务 Task1处于运行态（占用CPU），运行过程中由于 Task2 就绪，在抢占式调度器的作用下任务 Task2 抢占Task1 的执行。 </p>
<p>所以：<strong>Task2 由就绪态进入到运行态，Task1 由运行态进入到就绪态</strong>。</p>
</li>
<li><p>任务 Task2 在运行中，由于 Task3 又处于了就绪态，在抢占式调度器的作用下任务 Task3 又抢占 Task2的执行。 </p>
<p>所以：<strong>Task3 由就绪态进入到运行态，Task2 由运行态进入到就绪态</strong>。 </p>
</li>
<li><p>任务 Task3 运行过程中调用了阻塞式 API 函数，比如 vTaskDelay，任务 Task3 被挂起，进入挂起态，在抢占式调度器的作用下查找到下一个要执行的最高优先级任务是 Task2，所以：<strong>任务 Task2 由就绪态又回到了运行态</strong>。</p>
</li>
<li><p>任务 Task2 在运行中，由于 Task3 的阻塞时间结束， Task3 再次就绪，在抢占式调度器的作用下<strong>任务 Task3 再次抢占Task2 的执行。 Task3 进入到运行态，Task2 由运行态进入到就绪态</strong>。</p>
</li>
</ul>
<h3 id="3-2-2-时间片调度示例"><a href="#3-2-2-时间片调度示例" class="headerlink" title="3.2.2 时间片调度示例"></a>3.2.2 时间片调度示例</h3><p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic/FreeRTOS/scheduler/scheduler-3.png"></p>
<ul>
<li>创建 4 个同优先级任务 Task1，Task2，Task3 和 Task4。</li>
<li>每个任务分配的时间片大小是 5 个系统时钟节拍。</li>
<li>先运行任务 Task1，运行够 5 个系统时钟节拍后，通过时间片调度切换到任务 Task2。</li>
<li>任务 Task2 运行够 5 个系统时钟节拍后，通过时间片调度切换到任务 Task3。</li>
<li>任务 Task3 在运行期间调用了<strong>阻塞式 API 函数</strong>，调用函数时，虽然 5 个系统时钟节拍的时间片大小还没有用完，此时依然会通过时间片调度切换到下一个任务 Task4。</li>
<li>任务 Task4 运行够 5 个系统时钟节拍后，通过时间片调度切换到任务 Task1。</li>
</ul>
<p>注：以上以5个Tick的时间片举例，而FreeRTOS的时间片只能是1个Tick。</p>
<h1 id="4-RTOS与TSOS"><a href="#4-RTOS与TSOS" class="headerlink" title="4 RTOS与TSOS"></a>4 RTOS与TSOS</h1><h2 id="RTOS"><a href="#RTOS" class="headerlink" title="RTOS"></a>RTOS</h2><p>英文为Real Time Operating System，即实时操作系统，<strong>实时</strong>是指当外界事件或数据产生时，能够接收并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的操作系统。</p>
<p>RTOS一般用于相对低速的MCU，比如运动控制类、按键输入等动作要求实时处理的系统，一般要求ms级，甚至us级响应。</p>
<h2 id="TSOS"><a href="#TSOS" class="headerlink" title="TSOS"></a>TSOS</h2><p>英文为Time Sharing Operating System，即分时操作系统，<strong>分时</strong>是指将系统处理机时间和内存空间按照一定的时间间隔（也就是我们所说的<strong>时间片</strong>）轮流地切换给各线程的程序使用。</p>
<p>TSOS一般用于相对高速的CPU，如多用户的桌面系统、服务器等系统（Windows、Linux）。</p>
<h2 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h2><p>RTOS具有高优先级任务<strong>抢占</strong>功能，以及同优先级间的<strong>时间片</strong>轮转调度，因而可以对事件进行及时响应（即具有较好的实时性），而TSOS是固定的时间片轮转调度，当有事件发送时，也只能等当前时间片执行完后，才能执行下一个时间片，因此可能不能及时响应某些紧急事件。</p>
<h1 id="5-FreeRTOS任务调度相关源码"><a href="#5-FreeRTOS任务调度相关源码" class="headerlink" title="5 FreeRTOS任务调度相关源码"></a>5 FreeRTOS任务调度相关源码</h1><h2 id="5-1-任务控制块TCB-t"><a href="#5-1-任务控制块TCB-t" class="headerlink" title="5.1 任务控制块TCB_t"></a>5.1 任务控制块TCB_t</h2><p>FreeRTOS对各个任务进行调度，首先需要一种方式来访问和控制各个任务，任务控制块就可以实现这种功能，它本质是一个结构体，记录了任务的堆栈指针、任务当前状态、任务优先级等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> StackType_t	*pxTopOfStack;	<span class="comment">/*栈顶 */</span></span><br><span class="line"></span><br><span class="line">	ListItem_t			xStateListItem;	    <span class="comment">/*标记任务状态的列表(Ready, Blocked, Suspended ) */</span></span><br><span class="line">	ListItem_t			xEventListItem;		<span class="comment">/*任务的事件列表 */</span></span><br><span class="line">	UBaseType_t			uxPriority;			<span class="comment">/*任务优先级 */</span></span><br><span class="line">	StackType_t			*pxStack;			<span class="comment">/*任务栈起始地址 */</span></span><br><span class="line">	<span class="keyword">char</span>				pcTaskName[ configMAX_TASK_NAME_LEN ]; <span class="comment">/*创建时给任务的描述性名称，便于调试 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>(...省略部分)</span></span><br><span class="line">	...省略部分</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; tskTCB;</span><br><span class="line"><span class="keyword">typedef</span> tskTCB TCB_t;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-阻塞延时vTaskDelay"><a href="#5-2-阻塞延时vTaskDelay" class="headerlink" title="5.2 阻塞延时vTaskDelay"></a>5.2 阻塞延时vTaskDelay</h2><p>当某个任务需要延时，调用vTaskDelay()，则该任务进入<strong>阻塞态</strong>，此时调度器会从就绪列表中找到优先级最高的就绪任务开始执行。</p>
<p>那vTaskDelay()里面具体执行了哪些内容你呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ( INCLUDE_vTaskDelay == 1 )</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">vTaskDelay</span><span class="params">( <span class="keyword">const</span> TickType_t xTicksToDelay )</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	BaseType_t xAlreadyYielded = pdFALSE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*delay时间为0则强制进行任务切换 */</span></span><br><span class="line">		<span class="keyword">if</span>( xTicksToDelay &gt; ( TickType_t ) <span class="number">0U</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			configASSERT( uxSchedulerSuspended == <span class="number">0</span> );</span><br><span class="line">            <span class="comment">/*停止任务调度*/</span></span><br><span class="line">			vTaskSuspenvdAll();</span><br><span class="line">			&#123;</span><br><span class="line">				traceTASK_DELAY();</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 在调度器被挂起时从事件列表中删除的任务，在恢复调度器之前，不会被放置在就绪列表中或从阻塞列表中删除</span></span><br><span class="line"><span class="comment">				此任务不能出现在事件列表中，因为它是当前正在执行的任务。*/</span></span><br><span class="line">				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );</span><br><span class="line">			&#125;</span><br><span class="line">			xAlreadyYielded = xTaskResumeAll();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			mtCOVERAGE_TEST_MARKER();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果xTaskResumeAll没有进行任务切换，则强制进行任务切换 */</span></span><br><span class="line">		<span class="keyword">if</span>( xAlreadyYielded == pdFALSE )</span><br><span class="line">		&#123;</span><br><span class="line">			portYIELD_WITHIN_API();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			mtCOVERAGE_TEST_MARKER();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* INCLUDE_vTaskDelay */</span></span></span><br></pre></td></tr></table></figure>

<p>vTaskDelay的延时参数是以tick为单位的，即vTaskDelay(1)延时1ms。</p>
<ul>
<li><p>当延时参数不为0时，即正常调用延时函数时，先停止任务调度，将当前任务添加至延时列表中，再恢复任务调度。</p>
</li>
<li><p>当延时参数为0时，会强制进行任务切换（portYIELD_WITHIN_API）（疑问：如果当前任务的优先级是最高的，虽然强制切换，但由于该任务的优先级最高，所起其实没有切换到其它任务？如果真的是强制切换到另一个任务，那上面时候这个最高优先级的任务再抢会CPU的使用权呢？）。</p>
</li>
</ul>
<h3 id="5-2-1添加任务到延时列表"><a href="#5-2-1添加任务到延时列表" class="headerlink" title="5.2.1添加任务到延时列表"></a>5.2.1添加任务到延时列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prvAddCurrentTaskToDelayedList</span><span class="params">( TickType_t xTicksToWait, <span class="keyword">const</span> BaseType_t xCanBlockIndefinitely )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TickType_t xTimeToWake;</span><br><span class="line"><span class="keyword">const</span> TickType_t xConstTickCount = xTickCount;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">	<span class="comment">//...省略部分</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在将任务添加到阻塞列表前先将其从就绪列表中移除*/</span></span><br><span class="line">	<span class="keyword">if</span>( uxListRemove( &amp;( pxCurrentTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 当前任务必定在就绪列表中, 所以无需检测, 并且port reset macro 可以被立即调用 */</span></span><br><span class="line">		portRESET_READY_PRIORITY( pxCurrentTCB-&gt;uxPriority, uxTopReadyPriority );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mtCOVERAGE_TEST_MARKER();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> ( INCLUDE_vTaskSuspend == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( ( xTicksToWait == portMAX_DELAY ) &amp;&amp; ( xCanBlockIndefinitely != pdFALSE ) )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 为确保不是被定时器事件唤醒，添加任务到挂起列表而不是延时列表. 它将会无定期的阻塞*/</span></span><br><span class="line">			vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 如果事件没有发生，计算任务应该被唤醒的时间。这可能会溢出，但这无关紧要，内核会正确地管理它*/</span></span><br><span class="line">			xTimeToWake = xConstTickCount + xTicksToWait;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 列表项将按唤醒顺序插入 */</span></span><br><span class="line">			listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xStateListItem ), xTimeToWake );</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>( xTimeToWake &lt; xConstTickCount )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 唤醒时间已溢出，将该项放入溢出列表 */</span></span><br><span class="line">				vListInsert( pxOverflowDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 唤醒时间未溢出，所以当前的阻塞列表被使用. */</span></span><br><span class="line">				vListInsert( pxDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 如果进入阻塞状态的任务被放置在阻塞任务列表的顶部，那么xNextTaskUnblockTime也需要更新 */</span></span><br><span class="line">				<span class="keyword">if</span>( xTimeToWake &lt; xNextTaskUnblockTime )</span><br><span class="line">				&#123;</span><br><span class="line">					xNextTaskUnblockTime = xTimeToWake;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					mtCOVERAGE_TEST_MARKER();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* INCLUDE_vTaskSuspend */</span></span></span><br><span class="line">	<span class="comment">//...省略部分</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* INCLUDE_vTaskSuspend */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-任务切换"><a href="#5-2-2-任务切换" class="headerlink" title="5.2.2 任务切换"></a>5.2.2 任务切换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> portNVIC_PENDSVSET_BIT		( 1UL &lt;&lt; 28UL ) <span class="comment">//PendSV的悬起位（第28位）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> portYIELD_WITHIN_API</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> portYIELD_WITHIN_API portYIELD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduler utilities. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> portYIELD()																\</span></span><br><span class="line"><span class="meta">&#123;																				\</span></span><br><span class="line"><span class="meta">	<span class="comment">/* Set a PendSV to request a context switch. */</span>								\</span></span><br><span class="line"><span class="meta">	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\</span></span><br><span class="line"><span class="meta">																				\</span></span><br><span class="line"><span class="meta">	<span class="comment">/* 触发PendSV，产生上下文切换 */</span>						\</span></span><br><span class="line"><span class="meta">	__dsb( portSY_FULL_READ_WRITE );											\</span></span><br><span class="line"><span class="meta">	__isb( portSY_FULL_READ_WRITE );											\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>portYIELD()任务切换函数，主要就是将PendSV的悬起位置1，在没有其它中断运行时执行PendSV中断服务函数，在这个中断函数中实现任务切换。</p>
<h3 id="5-2-3-PendSV中断服务函数"><a href="#5-2-3-PendSV中断服务函数" class="headerlink" title="5.2.3 PendSV中断服务函数"></a>5.2.3 PendSV中断服务函数</h3><p>PendSV中断服务函数是一段汇编代码，可能不太容易看懂，该函数需要先了解如下：</p>
<p>外部变量pxCurrentTCB是当前正在运行的任务的任务控制块</p>
<p>当进入PendSV中断服务函数时，上一任务的运行环境为：xPSR，PC(任务入口地址)，R14，R12，R3,R2,R1,R0（任务的形参），这些CPU寄存器的值会自动保存到任务的栈中，剩下的R4~R11需要手动保存。</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic/FreeRTOS/scheduler/scheduler-4.png"></p>
<p>总的来说，该函数实现3部分功能：上文保存，下文切换，中间调用了一个C函数vTaskSwitchContext，用于寻找要运行的任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__asm <span class="keyword">void</span> <span class="title">xPortPendSVHandler</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> uxCriticalNesting;</span><br><span class="line">	<span class="keyword">extern</span> pxCurrentTCB;</span><br><span class="line">	<span class="keyword">extern</span> vTaskSwitchContext;</span><br><span class="line"></span><br><span class="line">	PRESERVE8</span><br><span class="line"></span><br><span class="line">	mrs r0, psp       <span class="comment">/* 保存当前任务PSP地址到R0中 */</span></span><br><span class="line">	isb</span><br><span class="line">	</span><br><span class="line">	ldr	r3, =pxCurrentTCB  <span class="comment">/* 获取pxCurrentTCBConst指针地址 */</span></span><br><span class="line">	ldr	r2, [r3]           <span class="comment">/* R2被赋予当前TCB地址 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Is the task using the FPU context?  If so, push high vfp registers. */</span></span><br><span class="line">	tst r14, #<span class="number">0x10</span></span><br><span class="line">	it eq</span><br><span class="line">	vstmdbeq r0!, &#123;s16-s31&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Save the core registers. */</span></span><br><span class="line">	stmdb r0!, &#123;r4-r11, r14&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Save the new top of stack into the first member of the TCB. */</span></span><br><span class="line">	str r0, [r2]</span><br><span class="line"></span><br><span class="line">	stmdb sp!, &#123;r3&#125;</span><br><span class="line">	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><span class="line">	msr basepri, r0  <span class="comment">/*屏蔽中断*/</span></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line">	bl vTaskSwitchContext  <span class="comment">/*调用vTaskSwitchContext*/</span></span><br><span class="line">	mov r0, #<span class="number">0</span></span><br><span class="line">	msr basepri, r0  <span class="comment">/*打开中断*/</span></span><br><span class="line">	ldmia sp!, &#123;r3&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The first item in pxCurrentTCB is the task top of stack. */</span></span><br><span class="line">	ldr r1, [r3] <span class="comment">/* R3依然是pxCurrentTCBConst指针地址，R1变为新TCB地址 */</span></span><br><span class="line">	ldr r0, [r1] <span class="comment">/* R0值成为新TCB的栈地址（该TCB发生上一次调度的PSP值） */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Pop the core registers. */</span></span><br><span class="line">	ldmia r0!, &#123;r4-r11, r14&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Is the task using the FPU context?  If so, pop the high vfp registers</span></span><br><span class="line"><span class="comment">	too. */</span></span><br><span class="line">	tst r14, #<span class="number">0x10</span></span><br><span class="line">	it eq</span><br><span class="line">	vldmiaeq r0!, &#123;s16-s31&#125;</span><br><span class="line"></span><br><span class="line">	msr psp, r0</span><br><span class="line">	isb</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> WORKAROUND_PMU_CM001 <span class="comment">/* XMC4000 specific errata */</span></span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> WORKAROUND_PMU_CM001 == 1</span></span><br><span class="line">			push &#123; r14 &#125;</span><br><span class="line">			pop &#123; pc &#125;</span><br><span class="line">			nop</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	bx r14</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-寻找要运行的任务"><a href="#5-2-4-寻找要运行的任务" class="headerlink" title="5.2.4 寻找要运行的任务"></a>5.2.4 寻找要运行的任务</h3><p>该函数实际是选择一个最高优先级的任务运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskSwitchContext</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* The scheduler is currently suspended - do not allow a context</span></span><br><span class="line"><span class="comment">		switch. */</span></span><br><span class="line">		xYieldPending = pdTRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		xYieldPending = pdFALSE;</span><br><span class="line">		traceTASK_SWITCHED_OUT();</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">		<span class="comment">//...省略部分</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configGENERATE_RUN_TIME_STATS */</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 检查堆栈是否溢出 */</span></span><br><span class="line">		taskCHECK_FOR_STACK_OVERFLOW();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 选择一个最高优先级的任务运行*/</span></span><br><span class="line">		taskSELECT_HIGHEST_PRIORITY_TASK();</span><br><span class="line">		traceTASK_SWITCHED_IN();</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line">		<span class="comment">//...省略部分</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* configUSE_NEWLIB_REENTRANT */</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择一个最高优先级的任务的函数实现如下：</p>
<p>获取任务的本质是获取任务的控制块(TCB)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">define <span class="title">taskSELECT_HIGHEST_PRIORITY_TASK</span><span class="params">()</span>														\</span></span><br><span class="line"><span class="function"></span>&#123;																								\</span><br><span class="line">UBaseType_t uxTopPriority;																		\</span><br><span class="line">																								\</span><br><span class="line">	<span class="comment">/* 寻找就绪任务的最高休闲级 */</span>							                                     	\</span><br><span class="line">	portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\</span><br><span class="line">	configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; <span class="number">0</span> );		\</span><br><span class="line">       <span class="comment">/*获取优先级最高的就绪任务的TCB,更新到pxCurrentTCB*/</span>                                             \</span><br><span class="line">	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );		\ </span><br><span class="line">&#125; <span class="comment">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span></span><br></pre></td></tr></table></figure>

<p>获取优先级最高的就绪任务的TCB的函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\</span></span><br><span class="line"><span class="meta">&#123;																							\</span></span><br><span class="line"><span class="meta">List_t * const pxConstList = ( pxList );													\</span></span><br><span class="line"><span class="meta">	<span class="comment">/* Increment the index to the next item and return the item, ensuring */</span>				\</span></span><br><span class="line"><span class="meta">	<span class="comment">/* we don&#x27;t return the marker used at the end of the list.  */</span>							\</span></span><br><span class="line"><span class="meta">	( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;							\</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">if</span>( ( void * ) ( pxConstList )-&gt;pxIndex == ( void * ) &amp;( ( pxConstList )-&gt;xListEnd ) )	\</span></span><br><span class="line"><span class="meta">	&#123;																						\</span></span><br><span class="line"><span class="meta">		( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;						\</span></span><br><span class="line"><span class="meta">	&#125;																						\</span></span><br><span class="line"><span class="meta">	( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner;											\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-停止-恢复任务调度"><a href="#5-3-停止-恢复任务调度" class="headerlink" title="5.3 停止/恢复任务调度"></a>5.3 停止/恢复任务调度</h2><h3 id="5-3-1-vTaskSuspenvdAll"><a href="#5-3-1-vTaskSuspenvdAll" class="headerlink" title="5.3.1 vTaskSuspenvdAll()"></a>5.3.1 vTaskSuspenvdAll()</h3><p>挂起调度程序可以防止发生上下文切换，但可以使能中断。如果在挂起调度程序时中断请求上下文切换，则该请求将保持挂起状态，并且仅在重新启动调度程序（未挂起）时才执行该请求。</p>
<p>该函数就是将调度器锁定，每调用一次该函数，会对变量uxSchedulerSuspended进行自加，用于嵌套调用时记录嵌套的深度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATA <span class="keyword">static</span> <span class="keyword">volatile</span> UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskSuspendAll</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	++uxSchedulerSuspended;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2xTaskResumeAll"><a href="#5-3-2xTaskResumeAll" class="headerlink" title="5.3.2xTaskResumeAll()"></a>5.3.2xTaskResumeAll()</h3><p>每调用一次vTaskSuspendAll()函数就会将uxSchedulerSuspended变量加一，那么调用对应的xTaskResumeAll()肯定就是将变量减一</p>
<p>如果恢复调度程序导致上下文切换，则返回pdTRUE，否则返回pdFALSE </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTaskResumeAll</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCB_t *pxTCB = <span class="literal">NULL</span>;</span><br><span class="line">BaseType_t xAlreadyYielded = pdFALSE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果uxSchedulerSuspended为0，则此函数与先前对vTaskSuspendAll（）的调用不匹配 */</span></span><br><span class="line">	configASSERT( uxSchedulerSuspended );</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当调度器被挂起时，ISR可能导致任务从事件列表中删除。如果是这种情况，</span></span><br><span class="line"><span class="comment">	那么删除的任务将被添加到xPendingReadyList中。一旦调度程序被恢复，</span></span><br><span class="line"><span class="comment">	就可以安全地将所有挂起的就绪任务从这个列表移动到它们相应的就绪列表中 */</span></span><br><span class="line">	taskENTER_CRITICAL();</span><br><span class="line">	&#123;</span><br><span class="line">		--uxSchedulerSuspended;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( uxCurrentNumberOfTasks &gt; ( UBaseType_t ) <span class="number">0U</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 将任何准备好的任务从待处理就绪列表移动到相应的就绪列表中 */</span></span><br><span class="line">				<span class="keyword">while</span>( listLIST_IS_EMPTY( &amp;xPendingReadyList ) == pdFALSE )</span><br><span class="line">				&#123;</span><br><span class="line">					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &amp;xPendingReadyList ) );</span><br><span class="line">					( <span class="keyword">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line">					( <span class="keyword">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line">					prvAddTaskToReadyList( pxTCB );</span><br><span class="line"></span><br><span class="line">					<span class="comment">/* 如果移动的任务的优先级高于当前任务，需要进行一次任务的切换 */</span></span><br><span class="line">					<span class="keyword">if</span>( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )</span><br><span class="line">					&#123;</span><br><span class="line">						xYieldPending = pdTRUE;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						mtCOVERAGE_TEST_MARKER();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>( pxTCB != <span class="literal">NULL</span> )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">/*当调度程序被挂起时，一个任务被解除阻塞，这可能阻止了重新计算下一个解除阻塞时间，</span></span><br><span class="line"><span class="comment">					在这种情况下，现在重新计算它。这对于低功耗无tickless实现非常重要，</span></span><br><span class="line"><span class="comment">					它可以防止从低功耗状态进行不必要的退出*/</span></span><br><span class="line">					prvResetNextTaskUnblockTime();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 如果在调度器被挂起时发生任何滴答，那么现在应该处理它们。</span></span><br><span class="line"><span class="comment">				这可以确保滴答计数不会滑动，并且任何延迟的任务都能在正确的时间恢复 */</span></span><br><span class="line">				&#123;</span><br><span class="line">					UBaseType_t uxPendedCounts = uxPendedTicks; <span class="comment">/* Non-volatile copy. */</span></span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span>( uxPendedCounts &gt; ( UBaseType_t ) <span class="number">0U</span> )</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">do</span></span><br><span class="line">						&#123;</span><br><span class="line">                            <span class="comment">/*查找是否有待进行切换的任务，如果有则应该进行任务切换*/</span></span><br><span class="line">							<span class="keyword">if</span>( xTaskIncrementTick() != pdFALSE )</span><br><span class="line">							&#123;</span><br><span class="line">								xYieldPending = pdTRUE;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">							&#123;</span><br><span class="line">								mtCOVERAGE_TEST_MARKER();</span><br><span class="line">							&#125;</span><br><span class="line">							--uxPendedCounts;</span><br><span class="line">						&#125; <span class="keyword">while</span>( uxPendedCounts &gt; ( UBaseType_t ) <span class="number">0U</span> );</span><br><span class="line"></span><br><span class="line">						uxPendedTicks = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						mtCOVERAGE_TEST_MARKER();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>( xYieldPending != pdFALSE )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="meta">#<span class="meta-keyword">if</span>( configUSE_PREEMPTION != 0 )</span></span><br><span class="line">					&#123;</span><br><span class="line">						xAlreadyYielded = pdTRUE;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    <span class="comment">/*如果需要任务切换，则调用taskYIELD_IF_USING_PREEMPTION()函数发起一次任务切换*/</span></span><br><span class="line">					taskYIELD_IF_USING_PREEMPTION();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					mtCOVERAGE_TEST_MARKER();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			mtCOVERAGE_TEST_MARKER();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> xAlreadyYielded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div><div style="text-align:center;color: #ccc;font-size:14px;font-family: cursive;">-------------&#x7EB8;&#x77ED;&#x60C5;&#x957F; <i class="fa fa-umbrella"></i> &#x4E0B;&#x6B21;&#x518D;&#x89C1;-------------</div></div><div id="wechat_subscriber"><center><img id="wechat_subscriber_qcode" src="undefined" onerror="onerror=null;src='https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/hexo/wxgzh.png'" alt="码农爱学习"></center><div>关注微信公众号，获取更多精彩~</div></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xxpcb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xxpcb.gitee.io/2021/05/03/FreeRTOS%E6%BA%90%E7%A0%81%E6%8E%A2%E6%9E%90%E4%B9%8B-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3/">http://xxpcb.gitee.io/2021/05/03/FreeRTOS%E6%BA%90%E7%A0%81%E6%8E%A2%E6%9E%90%E4%B9%8B-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xxpcb.gitee.io" target="_blank">码农爱学习的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/FreeRTOS/">FreeRTOS</a></div><div class="post_share"><div class="social-share" data-image="/img/default-cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/03/FreeRTOS%E6%BA%90%E7%A0%81%E6%8E%A2%E6%9E%90%E4%B9%8B-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><img class="prev-cover" src="/img/default-cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">FreeRTOS源码探析之--消息队列</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/03/FreeRTOS%E6%BA%90%E7%A0%81%E6%8E%A2%E6%9E%90%E4%B9%8B-%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84/"><img class="next-cover" src="/img/default-cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">FreeRTOS源码探析之--事件标志组</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/06/03/FreeRTOS例程1-基础任务创建/" title="FreeRTOS例程1-基础任务创建"><img class="cover" src="/img/default-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-03</div><div class="title">FreeRTOS例程1-基础任务创建</div></div></a></div><div><a href="/2020/07/05/FreeRTOS例程3-串口中断接收不定长的数据与二值信号量的使用/" title="FreeRTOS例程3-串口中断接收不定长的数据与二值信号量的使用"><img class="cover" src="/img/default-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">FreeRTOS例程3-串口中断接收不定长的数据与二值信号量的使用</div></div></a></div><div><a href="/2020/07/13/FreeRTOS例程4-串口DMA收发不定长数据/" title="FreeRTOS例程4-串口DMA收发不定长数据"><img class="cover" src="/img/default-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-13</div><div class="title">FreeRTOS例程4-串口DMA收发不定长数据</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xxpcb</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">141</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/xxpcb"><i class="fab fa-github"></i><span>Follow Me (gitee)</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxpcb" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">分享：单片机、嵌入式、ARM、Linux、C/C++、python等技术文章~ <img src="/img/wxgzh-card.png"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B%E4%B8%8ERTOS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">1 裸机编程与RTOS 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 裸机程序基本框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-RTOS%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 RTOS程序基本框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-RTOS%E4%BB%BB%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">2.</span> <span class="toc-text">2 RTOS任务间通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-RTOS%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">3 RTOS任务调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 任务状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 抢占式调度示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 时间片调度示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-RTOS%E4%B8%8ETSOS"><span class="toc-number">4.</span> <span class="toc-text">4 RTOS与TSOS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RTOS"><span class="toc-number">4.1.</span> <span class="toc-text">RTOS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TSOS"><span class="toc-number">4.2.</span> <span class="toc-text">TSOS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">主要区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-FreeRTOS%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">5 FreeRTOS任务调度相关源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97TCB-t"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 任务控制块TCB_t</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E9%98%BB%E5%A1%9E%E5%BB%B6%E6%97%B6vTaskDelay"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 阻塞延时vTaskDelay</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E5%88%B0%E5%BB%B6%E6%97%B6%E5%88%97%E8%A1%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1添加任务到延时列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2 任务切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-PendSV%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3 PendSV中断服务函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E5%AF%BB%E6%89%BE%E8%A6%81%E8%BF%90%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4 寻找要运行的任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%81%9C%E6%AD%A2-%E6%81%A2%E5%A4%8D%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 停止&#x2F;恢复任务调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-vTaskSuspenvdAll"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 vTaskSuspenvdAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2xTaskResumeAll"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2xTaskResumeAll()</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/18/%E5%B5%8C%E5%85%A5%E5%BC%8FQt-%E6%8E%A7%E5%88%B6%E7%A1%AC%E4%BB%B6-%E6%BB%91%E5%8A%A8%E6%9D%A1%E6%8E%A7%E5%88%B6RGB%E7%81%AF/" title="嵌入式Qt-控制硬件-滑动条控制RGB灯"><img src="/../img/imx/qt5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嵌入式Qt-控制硬件-滑动条控制RGB灯"/></a><div class="content"><a class="title" href="/2022/08/18/%E5%B5%8C%E5%85%A5%E5%BC%8FQt-%E6%8E%A7%E5%88%B6%E7%A1%AC%E4%BB%B6-%E6%BB%91%E5%8A%A8%E6%9D%A1%E6%8E%A7%E5%88%B6RGB%E7%81%AF/" title="嵌入式Qt-控制硬件-滑动条控制RGB灯">嵌入式Qt-控制硬件-滑动条控制RGB灯</a><time datetime="2022-08-18T14:47:00.000Z" title="发表于 2022-08-18 22:47:00">2022-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/08/%E5%B5%8C%E5%85%A5%E5%BC%8FQt-%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%87%E6%8D%A2/" title="嵌入式Qt-实现两个窗口的切换"><img src="/../img/imx/qt4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嵌入式Qt-实现两个窗口的切换"/></a><div class="content"><a class="title" href="/2022/08/08/%E5%B5%8C%E5%85%A5%E5%BC%8FQt-%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%87%E6%8D%A2/" title="嵌入式Qt-实现两个窗口的切换">嵌入式Qt-实现两个窗口的切换</a><time datetime="2022-08-08T15:32:32.000Z" title="发表于 2022-08-08 23:32:32">2022-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/08/%E5%B5%8C%E5%85%A5%E5%BC%8FQt-%E5%81%9A%E4%B8%80%E4%B8%AA%E7%A7%92%E8%A1%A8/" title="嵌入式Qt-做一个秒表"><img src="/../img/imx/qt3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嵌入式Qt-做一个秒表"/></a><div class="content"><a class="title" href="/2022/08/08/%E5%B5%8C%E5%85%A5%E5%BC%8FQt-%E5%81%9A%E4%B8%80%E4%B8%AA%E7%A7%92%E8%A1%A8/" title="嵌入式Qt-做一个秒表">嵌入式Qt-做一个秒表</a><time datetime="2022-08-08T15:32:21.000Z" title="发表于 2022-08-08 23:32:21">2022-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/31/%E5%B5%8C%E5%85%A5%E5%BC%8FQt-%E5%8A%A8%E6%89%8B%E7%BC%96%E5%86%99%E5%B9%B6%E8%BF%90%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%AC1%E4%B8%AAARM-Qt%E7%A8%8B%E5%BA%8F/" title="嵌入式Qt-动手编写并运行自己的第1个ARM-Qt程序"><img src="/../img/imx/qt2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嵌入式Qt-动手编写并运行自己的第1个ARM-Qt程序"/></a><div class="content"><a class="title" href="/2022/07/31/%E5%B5%8C%E5%85%A5%E5%BC%8FQt-%E5%8A%A8%E6%89%8B%E7%BC%96%E5%86%99%E5%B9%B6%E8%BF%90%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%AC1%E4%B8%AAARM-Qt%E7%A8%8B%E5%BA%8F/" title="嵌入式Qt-动手编写并运行自己的第1个ARM-Qt程序">嵌入式Qt-动手编写并运行自己的第1个ARM-Qt程序</a><time datetime="2022-07-31T03:28:33.000Z" title="发表于 2022-07-31 11:28:33">2022-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/31/STM32%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B-%E5%85%A8%E8%87%AA%E5%8A%A8%E6%B4%97%E8%A1%A3%E6%9C%BA-%E4%B8%8B/" title="STM32状态机编程实例--全自动洗衣机(下)"><img src="/../img/stm32/8-washer2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32状态机编程实例--全自动洗衣机(下)"/></a><div class="content"><a class="title" href="/2022/07/31/STM32%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B-%E5%85%A8%E8%87%AA%E5%8A%A8%E6%B4%97%E8%A1%A3%E6%9C%BA-%E4%B8%8B/" title="STM32状态机编程实例--全自动洗衣机(下)">STM32状态机编程实例--全自动洗衣机(下)</a><time datetime="2022-07-31T03:21:37.000Z" title="发表于 2022-07-31 11:21:37">2022-07-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/default-cover.png')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By xxpcb</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'P6iS1Ip0yj2xKyDmnnT8mMrk-gzGzoHsz',
      appKey: 'bHIkuKIeQSpeQgKoE3vtEYKs',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>