<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【i.MX6ULL】驱动开发1--字符设备开发模板 | 码农爱学习的博客</title><meta name="keywords" content="Linux,嵌入式,ARM,驱动"><meta name="author" content="xxpcb"><meta name="copyright" content="xxpcb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="之前的几篇文章（从i.MX6ULL嵌入式Linux开发1-uboot移植初探起)，介绍了嵌入式了Linux的系统移植（uboot、内核与根文件系统）以及使用MfgTool工具将系统烧写到板子的EMMC中。 本篇开始介绍嵌入式Linux驱动开发。">
<meta property="og:type" content="article">
<meta property="og:title" content="【i.MX6ULL】驱动开发1--字符设备开发模板">
<meta property="og:url" content="http://xxpcb.gitee.io/2021/08/26/%E3%80%90i-MX6ULL%E3%80%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%911-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/index.html">
<meta property="og:site_name" content="码农爱学习的博客">
<meta property="og:description" content="之前的几篇文章（从i.MX6ULL嵌入式Linux开发1-uboot移植初探起)，介绍了嵌入式了Linux的系统移植（uboot、内核与根文件系统）以及使用MfgTool工具将系统烧写到板子的EMMC中。 本篇开始介绍嵌入式Linux驱动开发。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xxpcb.gitee.io/img/imx/bsp1.png">
<meta property="article:published_time" content="2021-08-25T16:06:15.000Z">
<meta property="article:modified_time" content="2021-09-04T08:42:33.947Z">
<meta property="article:author" content="xxpcb">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="驱动">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xxpcb.gitee.io/img/imx/bsp1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://xxpcb.gitee.io/2021/08/26/%E3%80%90i-MX6ULL%E3%80%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%911-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//s4.cnzz.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f9c11fefaddf7b7687633a168777f8d9"; //- "https://hm.baidu.com/hm.js?true";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">document.write(unescape("%3Cspan style='display:none;' id='cnzz_stat_icon_1277776467'%3E%3C/span%3E%3Cscript src='https://s23.cnzz.com/z_stat.php%3Fid%3D1277776467%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【i.MX6ULL】驱动开发1--字符设备开发模板',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-04 16:42:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../img/imx/bsp1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">码农爱学习的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【i.MX6ULL】驱动开发1--字符设备开发模板</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-25T16:06:15.000Z" title="发表于 2021-08-26 00:06:15">2021-08-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-04T08:42:33.947Z" title="更新于 2021-09-04 16:42:33">2021-09-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/i-MX6ULL/">i.MX6ULL</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>之前的几篇文章（从<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/389091057">i.MX6ULL嵌入式Linux开发1-uboot移植初探</a>起)，介绍了嵌入式了<strong>Linux的系统移植</strong>（uboot、内核与根文件系统）以及使用MfgTool工具将<strong>系统烧写</strong>到板子的EMMC中。</p>
<p>本篇开始介绍嵌入式<strong>Linux驱动</strong>开发。</p>
<span id="more"></span>

<p>内容较多，先看目录：</p>
<p>[TOC]</p>
<h1 id="1-Linux驱动分类"><a href="#1-Linux驱动分类" class="headerlink" title="1 Linux驱动分类"></a>1 Linux驱动分类</h1><p>Linux中的外设驱动可以分为三大类：字符设备驱动、块设备驱动和网络设备驱动。</p>
<ul>
<li><strong>字符设备驱动</strong>：字符设备是能够按照字节流（比如文件）进行读写操作的设备。字符设备最常见，从最简单的点灯到I2C、SPI、音频等都属于字符设备驱动</li>
<li><strong>块设备驱动</strong>：以存储块为基础的设备驱动，如EMMC、NAND、SD卡等。对用户而言，字符设备与块设备的访问方式没有差别。</li>
<li><strong>网络设备驱动</strong>：即网络驱动，它同时具有字符设备和块设备的特点，因为它是输入输出是有结构块的（报文，包，帧），但它的块的大小又不是固定的。</li>
</ul>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/1.png"></p>
<h1 id="2-Linux驱动基本原理"><a href="#2-Linux驱动基本原理" class="headerlink" title="2 Linux驱动基本原理"></a>2 Linux驱动基本原理</h1><p>在<strong>Linux中一切皆文件</strong>，驱动加载成功以后会在“**/dev<strong>”目录下生成一个相应的文件，应用程序通过对这个名为“</strong>/dev/xxx**”的文件进行相应的操作即可实现对硬件的操作。</p>
<p>比如<strong>最简单的点灯功能</strong>，会有/dev/led这样的驱动文件，应用程序使用<strong>open</strong>函数来打开文件/dev/led，如果要<strong>点亮或关闭led</strong>，那么就使用<strong>write</strong>函数写入开关值，如果要<strong>获取led的状态</strong>，就用<strong>read</strong>函数从驱动中读取相应的状态，使用完成以后使用<strong>close</strong>函数关闭/dev/led这个文件。</p>
<h2 id="2-1-Linux软件分层结构"><a href="#2-1-Linux软件分层结构" class="headerlink" title="2.1 Linux软件分层结构"></a>2.1 Linux软件分层结构</h2><p>Linux软件从上到下可以分层4层结构，以控制LED为例：</p>
<ul>
<li><p><strong>应用层</strong>：应用程序使用库提供的open函数打开LED设备</p>
</li>
<li><p><strong>库</strong>：库根据open函数传入的参数执行“swi”指令，进而引起CPU异常，进入内核</p>
</li>
<li><p><strong>内核</strong>：内核的异常处理函数根据传入的参数找到对应的驱动程序，返回文件句柄给库，进而返回给应用层</p>
</li>
<li><p>应用层得到文件句柄后，使用库提供的write或ioctl发出控制指令</p>
</li>
<li><p>库根据write或ioctl函数传入的参数执行“swi”指令，进入内核</p>
</li>
<li><p>内核的异常处理函数根据传入的参数找到对应的驱动程序</p>
</li>
<li><p><strong>驱动</strong>：驱动程序控制硬件，点亮LED</p>
</li>
</ul>
<p>应用程序运行在<strong>用户空间</strong>，而Linux驱动属于内核的一部分，因此驱动运行于<strong>内核空间</strong>。当应用层通过open函数打开/dev/led 这个驱动时，因用户空间不能直接操作内核，因此会使用“<strong>系统调用</strong>”的方法来从用户空间“<strong>陷入</strong>”到内核空间，实现对底层驱动的操作。</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/2.png"></p>
<p>比如<strong>应用程序</strong>调用了open这个函数，则在<strong>驱动程序</strong>中也应有一个对应的open的函数。</p>
<h2 id="2-2-Linux内核驱动操作函数"><a href="#2-2-Linux内核驱动操作函数" class="headerlink" title="2.2 Linux内核驱动操作函数"></a>2.2 Linux内核驱动操作函数</h2><p>每一个系统调用，在驱动中都有与之对应的一个驱动函数，在Linux内核文件<strong>include/linux/fs.h</strong>中有个<strong>file_operations</strong>结构体，就是Linux内核驱动操作函数集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">	<span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">	<span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">	<span class="keyword">int</span> (*mremap)(struct file *, struct vm_area_struct *);</span><br><span class="line">	<span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">	<span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="comment">/*省略若干行...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中有关<strong>字符设备驱动</strong>开发中常用的函数有：</p>
<ul>
<li>owner：拥有该结构体的模块的指针，一般设置为THIS_MODULE。 </li>
<li>llseek函数：用于修改文件当前的读写位置。 </li>
<li>read函数：用于读取设备文件。 </li>
<li>write函数：用于向设备文件写入(发送)数据。 </li>
<li>poll函数：是个轮询函数，用于查询设备是否可以进行非阻塞的读写。 </li>
<li>unlocked_ioctl函数：提供对于设备的控制功能， 与应用程序中的 ioctl 函数对应。 </li>
<li>compat_ioctl函数：与 unlocked_ioctl功能一样，区别在于在 64 位系统上，32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是unlocked_ioctl。 </li>
<li>mmap函数：用于将将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数， 比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制。 </li>
<li>open函数：用于打开设备文件。 </li>
<li>release函数：用于释放(关闭)设备文件，与应用程序中的 close 函数对应。 </li>
<li>fasync函数：用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中。 </li>
<li>aio_fsync函数：与fasync功能类似，只是 aio_fsync 是异步刷新待处理的</li>
</ul>
<h2 id="2-3-Linux驱动运行方式"><a href="#2-3-Linux驱动运行方式" class="headerlink" title="2.3 Linux驱动运行方式"></a>2.3 Linux驱动运行方式</h2><p>Linux 驱动有两种运行方式：</p>
<ul>
<li>将驱动编译进<strong>Linux内核</strong>中， 这样当Linux内核启动的时候就会自动运行驱动程序。 </li>
<li>将驱动编译成<strong>模块</strong>(扩展名为 <strong>.ko</strong>)， 在Linux内核启动以后使用“insmod”命令加载驱动模块。</li>
</ul>
<p>在驱动开发阶段一般都将其编译为模块，不需要编译整个Linux代码，方便调试驱动程序。当驱动开发完成后，根据实际需要，可以选择是否将驱动编译进Linux内核中。</p>
<h2 id="2-4-Linux设备号"><a href="#2-4-Linux设备号" class="headerlink" title="2.4 Linux设备号"></a>2.4 Linux设备号</h2><h3 id="2-4-1-设备号的组成"><a href="#2-4-1-设备号的组成" class="headerlink" title="2.4.1 设备号的组成"></a>2.4.1 设备号的组成</h3><p>Linux中每个设备都有一个设备号，设备号由主设备号和次设备号两部分组成。</p>
<ul>
<li>主设备号：表示某一个具体的驱动</li>
<li>次设备号：表示使用这个驱动的各个设备</li>
</ul>
<p>Linux 提供了名为dev_t的数据类型表示设备号，其本质是32位的unsigned int数据类型，其中<strong>高12位为主设备号，低2 位为次设备号</strong>，因此Linux中主设备号范围为<strong>0~4095</strong>。</p>
<p>在文件include/linux/kdev_t.h中提供了几个关于设备号操作的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORBITS     20 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORMASK     ((1U &lt;&lt; MINORBITS) - 1) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR(dev)    ((unsigned int) ((dev) &gt;&gt; MINORBITS)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(dev)    ((unsigned int) ((dev) &amp; MINORMASK)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKDEV(ma,mi)  (((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MINORBITS：表示次设备号位数，一共20位</li>
<li>MINORMASK：表示次设备号掩码</li>
<li>MAJOR：用于从dev_t中获取主设备号，将dev_t右移20位即可</li>
<li>MINOR：用于从dev_t中获取次设备号，取dev_t的低20位的值即可</li>
<li>MKDEV：用于将给定的主设备号和次设备号的值组合成dev_t类型的设备号</li>
</ul>
<h3 id="2-4-2-主设备号的分配"><a href="#2-4-2-主设备号的分配" class="headerlink" title="2.4.2 主设备号的分配"></a>2.4.2 主设备号的分配</h3><p>主设备号的分配包括静态分配和动态分配</p>
<ul>
<li><strong>静态分配</strong>需要手动指定设备号，并且要注意不能与已有的重复，一些常用的设备号已经被Linux内核开发者给分配掉了，使用“cat /proc/devices”命令可查看当前系统中所有已经使用了的设备号。</li>
<li><strong>动态分配</strong>是在注册字符设备之前先申请一个设备号，系统会自动分配一个没有被使用的设备号， 这样就避免了冲突。在卸载驱动的时候释放掉这个设备号即可。</li>
</ul>
<p>设备号的申请函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* dev：保存申请到的设备号</span></span><br><span class="line"><span class="comment">* baseminor：次设备号起始地址，一般baseminor为0 (次设备号以baseminor为起始地址地址开始递)</span></span><br><span class="line"><span class="comment">* count：要申请的设备号数量</span></span><br><span class="line"><span class="comment">* name：设备名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span></span><br></pre></td></tr></table></figure>

<p>设备号的释放函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* from：要释放的设备号</span></span><br><span class="line"><span class="comment">* count：表示从from开始，要释放的设备号数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count)</span> </span></span><br></pre></td></tr></table></figure>

<h1 id="3-字符设备驱动开发模板"><a href="#3-字符设备驱动开发模板" class="headerlink" title="3 字符设备驱动开发模板"></a>3 字符设备驱动开发模板</h1><h2 id="3-1-加载与卸载"><a href="#3-1-加载与卸载" class="headerlink" title="3.1 加载与卸载"></a>3.1 加载与卸载</h2><p>在编写驱动的时候需要注册模块加载和卸载这两种函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(xxx_init);   <span class="comment">//注册模块加载函数 </span></span><br><span class="line">module_exit(xxx_exit);   <span class="comment">//注册模块卸载函数 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>module_init()</code>用来向Linux内核注册一个模块加载函数，参数xxx_init就是需要注册的具体函数，当使用 “insmod” 命令加载驱动的时候，xxx_init这个函数就会被调用。 </p>
</li>
<li><p><code>module_exit()</code>用来向Linux内核注册一个模块卸载函数，参数xxx_exit就是需要注册的具体函数，当使<br>用“rmmod”命令卸载具体驱动的时候 xxx_exit函数就会被调用。</p>
</li>
</ul>
<p>字符设备驱动模块加载和卸载模板如下所示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 驱动入口函数 */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">xxx_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/*入口函数内容 */</span> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">xxx_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/*出口函数内容*/</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定为驱动的入口和出口函数 */</span> </span><br><span class="line">module_init(xxx_init); </span><br><span class="line">module_exit(xxx_exit); </span><br></pre></td></tr></table></figure>

<p>驱动编译完成以后扩展名为.ko， 有两种命令可以<strong>加载驱动</strong>模块:</p>
<ul>
<li><p><code>insmod</code>：最简单的模块加载命令，用于加载指定的.ko模块，此命令不能解决模块的依赖关系</p>
</li>
<li><p><code>modprobe</code>：该命令会分析模块的依赖关系，将所有的依赖模块都加载到内核中，因此更智能</p>
<p>modprobe 命令默认会去<code>/lib/modules/&lt;kernel-version&gt;</code>目录中查找模块（自制的根文件系统没有这个目录，需要手动创建）</p>
</li>
</ul>
<p><strong>卸载驱动</strong>也有两种命令：</p>
<ul>
<li><code>rmmod</code>：例如使用<code>rmmod drv.ko</code>来卸载 drv.ko这一个模块</li>
<li><code>modprobe -r</code>：该命令除了卸载指定的驱动，还卸载其所依赖的其他模块，若这些依赖模块还在被其它模块使用，就不能使用 modprobe来卸载驱动模块！！！</li>
</ul>
<h2 id="3-2-注册与注销"><a href="#3-2-注册与注销" class="headerlink" title="3.2 注册与注销"></a>3.2 注册与注销</h2><p>对于字符设备驱动而言，当驱动模块加载成功以后需要<strong>注册字符设备</strong>，同样，卸载驱动模块的时候也需要<strong>注销掉字符设备</strong>。</p>
<p>字符设备的<strong>注册函数</strong>原型如下所示: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* func: register_chrdev 注册字符设备</span></span><br><span class="line"><span class="comment">* major:主设备号</span></span><br><span class="line"><span class="comment">* name:设备名字，指向一串字符串</span></span><br><span class="line"><span class="comment">* fops:结构体 file_operations 类型指针，指向设备的操作函数集合变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">register_chrdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> struct file_operations *fops)</span> </span></span><br></pre></td></tr></table></figure>

<p>字符设备的<strong>注销函数</strong>原型如下所示: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* func: unregister_chrdev 注销字符设备</span></span><br><span class="line"><span class="comment">* majo:要注销的设备对应的主设备号 </span></span><br><span class="line"><span class="comment">* name:要注销的设备对应的设备名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unregister_chrdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span></span><br></pre></td></tr></table></figure>



<p>一般字符设备的注册在驱动模块的<strong>入口函数 <strong>xxx_init 中进行，字符设备的注销在驱动模块的</strong>出口函数</strong> xxx_exit 中进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">test_fops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">xxx_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/* 入口函数具体内容 */</span> </span><br><span class="line">    <span class="keyword">int</span> retvalue = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">/* 注册字符设备驱动 */</span> </span><br><span class="line">	retvalue = register_chrdev(<span class="number">200</span>, <span class="string">&quot;chrtest&quot;</span>, &amp;test_fops); </span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">		<span class="comment">/*  字符设备注册失败, 自行处理 */</span> </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">xxx_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/* 注销字符设备驱动 */</span> </span><br><span class="line">	unregister_chrdev(<span class="number">200</span>, <span class="string">&quot;chrtest&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span> </span><br><span class="line">module_init(xxx_init); </span><br><span class="line">module_exit(xxx_exit); </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：选择没有被使用的主设备号，可输入命令“cat /proc/devices”来查看当前已经被使用掉的设备号</p>
</blockquote>
<h2 id="3-3-实现设备的具体操作函数"><a href="#3-3-实现设备的具体操作函数" class="headerlink" title="3.3 实现设备的具体操作函数"></a>3.3 实现设备的具体操作函数</h2><p>file_operations 结构体就是设备的具体操作函数。</p>
<p>假设对chrtest这个设备有如下两个要求： </p>
<ul>
<li>能够实现打开和关闭操作：需要实现 file_operations 中的<strong>open</strong>和<strong>release</strong>这两个函数</li>
<li>能够实现进行读写操作：需要实现 file_operations 中的<strong>read</strong>和<strong>write</strong>这两个函数</li>
</ul>
<p>首先是 <strong>打开(open)、读取(read)、写入(write)、释放(release)</strong> 4个基本操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*打开设备*/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrtest_open</span><span class="params">(struct inode *inode, struct file *filp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/*用户实现具体功能*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*从设备读取*/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">chrtest_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> cnt, <span class="keyword">loff_t</span> *offt)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/*用户实现具体功能*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写数据*/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">chrtest_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> cnt, <span class="keyword">loff_t</span> *offt)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/*用户实现具体功能*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*关闭释放设备*/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrtest_release</span><span class="params">(struct inode *inode, struct file *filp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	 <span class="comment">/*用户实现具体功能*/</span> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后是 <strong>驱动的入口(init)和出口(exit)</strong> 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*文件操作结构体*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">test_fops</span> =</span> &#123; </span><br><span class="line">	.owner = THIS_MODULE,    </span><br><span class="line">	.open = chrtest_open, </span><br><span class="line">	.read = chrtest_read, </span><br><span class="line">	.write = chrtest_write, </span><br><span class="line">	.release = chrtest_release, </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*驱动入口函数*/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">xxx_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/*入口函数具体内容*/</span> </span><br><span class="line">	<span class="keyword">int</span> retvalue = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span> </span><br><span class="line">	retvalue = register_chrdev(<span class="number">200</span>, <span class="string">&quot;chrtest&quot;</span>, &amp;test_fops); </span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">		<span class="comment">/*字符设备注册失败*/</span> </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*驱动出口函数*/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">xxx_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*注销字符设备驱动*/</span> </span><br><span class="line">	unregister_chrdev(<span class="number">200</span>, <span class="string">&quot;chrtest&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定为驱动的入口和出口函数*/</span> </span><br><span class="line">module_init(xxx_init); </span><br><span class="line">module_exit(xxx_exit); </span><br></pre></td></tr></table></figure>

<h2 id="3-4-添加LICENSE和作者信息"><a href="#3-4-添加LICENSE和作者信息" class="headerlink" title="3.4 添加LICENSE和作者信息"></a>3.4 添加LICENSE和作者信息</h2><p>LICENSE是必须添加的，否则编译时会报错，作者信息可加可不加。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MODULE_LICENSE()  <span class="comment">//添加模块 LICENSE 信息 </span></span><br><span class="line">MODULE_AUTHOR()   <span class="comment">//添加模块作者信息</span></span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/3.png"></p>
<h1 id="4-字符设备驱动开发实验"><a href="#4-字符设备驱动开发实验" class="headerlink" title="4 字符设备驱动开发实验"></a>4 字符设备驱动开发实验</h1><p>下面以<strong>正点原子</strong>提供的教程中的chrdevbase这个虚拟设备为例，完整的编写一个字符设备驱动模块。chrdevbase不是实际存在的一个设备，只是为了学习字符设备的开发的流程。</p>
<h2 id="4-1-程序编写"><a href="#4-1-程序编写" class="headerlink" title="4.1 程序编写"></a>4.1 程序编写</h2><p>需要分别编写<strong>驱动程序</strong>和<strong>应用程序</strong>。</p>
<blockquote>
<p>注：为了区分两个程序的打印信息，在<strong>驱动程序</strong>的打印前都添加<strong>“[BSP]”标识</strong>，在<strong>应用程序</strong>的打印前都添加<strong>”[APP]“标识</strong>。</p>
</blockquote>
<h3 id="4-1-1-编写驱动程序"><a href="#4-1-1-编写驱动程序" class="headerlink" title="4.1.1 编写驱动程序"></a>4.1.1 编写驱动程序</h3><ul>
<li>一些定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHRDEVBASE_MAJOR	200				<span class="comment">/*主设备号*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHRDEVBASE_NAME		<span class="meta-string">&quot;chrdevbase&quot;</span> 	<span class="comment">/*设备名*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> readbuf[<span class="number">100</span>];		<span class="comment">/*读缓冲区*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> writebuf[<span class="number">100</span>];		<span class="comment">/*写缓冲区*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> kerneldata[] = &#123;<span class="string">&quot;kernel data!&quot;</span>&#125;; <span class="comment">/*内核驱动中的数据，用来测试应用程序读取该数据*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>打开、关闭、读取、写入</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode 	: 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> * 					  一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdevbase_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;[BSP] chrdevbase open!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 从设备读取数据 </span></span><br><span class="line"><span class="comment"> * @param - filp 	: 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @param - buf 	: 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param - cnt 	: 要读取的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt 	: 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return 			: 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">chrdevbase_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> cnt, <span class="keyword">loff_t</span> *offt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retvalue = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 向用户空间发送数据 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(readbuf, kerneldata, <span class="keyword">sizeof</span>(kerneldata));</span><br><span class="line">    </span><br><span class="line">	retvalue = copy_to_user(buf, readbuf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		printk(<span class="string">&quot;[BSP] kernel senddata ok!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">		printk(<span class="string">&quot;[BSP] kernel senddata failed!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;[BSP] chrdevbase read!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 向设备写数据 </span></span><br><span class="line"><span class="comment"> * @param - filp 	: 设备文件，表示打开的文件描述符</span></span><br><span class="line"><span class="comment"> * @param - buf 	: 要写给设备写入的数据</span></span><br><span class="line"><span class="comment"> * @param - cnt 	: 要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt 	: 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return 			: 写入的字节数，如果为负值，表示写入失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">chrdevbase_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> cnt, <span class="keyword">loff_t</span> *offt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retvalue = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 接收用户空间传递给内核的数据并且打印出来 */</span></span><br><span class="line">	retvalue = copy_from_user(writebuf, buf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		printk(<span class="string">&quot;[BSP] kernel recevdata:%s\n&quot;</span>, writebuf);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">		printk(<span class="string">&quot;[BSP] kernel recevdata failed!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;[BSP] chrdevbase write!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 关闭/释放设备</span></span><br><span class="line"><span class="comment"> * @param - filp 	: 要关闭的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdevbase_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;[BSP] chrdevbase release！\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>驱动加载与注销</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设备操作函数结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">chrdevbase_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,	</span><br><span class="line">	.open = chrdevbase_open,</span><br><span class="line">	.read = chrdevbase_read,</span><br><span class="line">	.write = chrdevbase_write,</span><br><span class="line">	.release = chrdevbase_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动入口函数 </span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">chrdevbase_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retvalue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line">	retvalue = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;chrdevbase_fops);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		printk(<span class="string">&quot;[BSP] chrdevbase driver register failed\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;[BSP] chrdevbase init!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">chrdevbase_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">	unregister_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME);</span><br><span class="line">	printk(<span class="string">&quot;[BSP] chrdevbase exit!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将上面两个函数指定为驱动的入口和出口函数*/</span></span><br><span class="line">module_init(chrdevbase_init);</span><br><span class="line">module_exit(chrdevbase_exit);</span><br></pre></td></tr></table></figure>

<ul>
<li>最后的LIENSE与作者</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*LICENSE和作者信息*/</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;zuozhongkai &amp; xxpcb&quot;</span>); <span class="comment">//本篇的程序代码在“正点原子”左大神提供的代码上进行修改</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-编写应用程序"><a href="#4-1-2-编写应用程序" class="headerlink" title="4.1.2 编写应用程序"></a>4.1.2 编写应用程序</h3><p>这里把程序截取为3段分析，<strong>首先看开头</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> usrdata[] = &#123;<span class="string">&quot;usr data!&quot;</span>&#125;; <span class="comment">/*应用程序中的数据，用于测试通过驱动访问写入内核*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd, retvalue;</span><br><span class="line">	<span class="keyword">char</span> *filename;</span><br><span class="line">	<span class="keyword">char</span> readbuf[<span class="number">100</span>], writebuf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[APP] Error Usage!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数1是驱动的文件名，用来指定驱动的位置</span></span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//【1】打开驱动文件</span></span><br><span class="line">	fd  = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[APP] Can&#x27;t open file %s\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[APP] open file: &#x27;%s&#x27; success\n&quot;</span>, filename);</span><br></pre></td></tr></table></figure>

<p>主要是一些头文件和main函数入口，调用main函数时需要传入2个参数（实际是3个参数，函数名本身是默认的第0个参数，不需要手动指定），具体作用为：</p>
<ul>
<li>参数0：argv[0]，函数名本身，这里不作用途</li>
<li>参数1：argv[1]，filename，这里不作用途</li>
<li>参数2：argv[2]，自定义的操作参数，下面函数会讲到，1为从驱动文件中读取，2为向驱动文件中写入数据</li>
</ul>
<p><strong>再来看具体操作：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//【2】从驱动文件读取数据</span></span><br><span class="line"><span class="keyword">if</span>(atoi(argv[<span class="number">2</span>]) == <span class="number">1</span>)<span class="comment">//参数1表示【读取】内核中的数据</span></span><br><span class="line">   &#123; </span><br><span class="line">	retvalue = read(fd, readbuf, <span class="number">50</span>);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[APP] read file &#x27;%s&#x27; failed!\n&quot;</span>, filename);</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">		<span class="comment">/* 读取成功，打印出读取成功的数据 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[APP] read data:%s\n&quot;</span>,readbuf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//【3】向设备驱动写数据</span></span><br><span class="line"><span class="keyword">if</span>(atoi(argv[<span class="number">2</span>]) == <span class="number">2</span>)<span class="comment">//参数2表示向内核中【写入】数据</span></span><br><span class="line">   &#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(writebuf, usrdata, <span class="keyword">sizeof</span>(usrdata));</span><br><span class="line">	retvalue = write(fd, writebuf, <span class="number">50</span>);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[APP] write file %s failed!\n&quot;</span>, filename);</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;[APP] write data:&#x27;%s&#x27; to file ok\n&quot;</span>, writebuf);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后是关闭设备</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//【4】关闭设备</span></span><br><span class="line">	retvalue = close(fd);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[APP] Can&#x27;t close file %s\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[APP] close file ok\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭即表示不再使用该设备了（若要再使用则重新打开即可），通过关闭驱动文件来实现字符设备驱动的关闭。</p>
<h2 id="4-2-程序编译"><a href="#4-2-程序编译" class="headerlink" title="4.2 程序编译"></a>4.2 程序编译</h2><h3 id="4-2-1-编译驱动程序"><a href="#4-2-1-编译驱动程序" class="headerlink" title="4.2.1 编译驱动程序"></a>4.2.1 编译驱动程序</h3><p>  编译驱动，即编译chrdevbase.c这个文件为.ko 模块，使用Makefile来编译，先创建Makefile： </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">KERNELDIR := /home/xxpcb/myTest/imx6ull/kernel/nxp_kernel/linux-imx-rel_imx_4.1.15_2.1.0_ga</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">obj-m := chrdevbase.o</span><br><span class="line"></span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure>

<p>各行含义：</p>
<ul>
<li><strong>KERNELDIR</strong>：开发板所使用的Linux内核源码目录</li>
<li><strong>CURRENT_PATH</strong>：当前路径，通过运行“pwd”命令获取</li>
<li><strong>obj-m</strong>：将 chrdevbase.c 这个文件编译为chrdevbase.ko模块</li>
<li><strong>具体的编译命令</strong>：后面的modules表示编译模块，-C 表示切换工作目录到KERNERLDIR目录，M表示模块源码目录</li>
</ul>
<p>输入“make”命令即可编译，编译后会出现许多编译文件</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/4.png"></p>
<blockquote>
<p>注：若直接make编译报如下错误，是因为kernel中没有指定编译器和架构，使用了默认的x86平台编译报错。</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/5.png"></p>
<p>修改Kernel工程的顶层Makefile，直接定义ARCH和CROSS_COMPILE 这两个的变量值为 arm 和 arm-linux-gnueabihf-</p>
<p>(内核篇的介绍见：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/393392685">i.MX6ULL嵌入式Linux开发3-Kernel移植</a>)</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/6.png"></p>
</blockquote>
<h3 id="4-2-2-编译应用程序"><a href="#4-2-2-编译应用程序" class="headerlink" title="4.2.2 编译应用程序"></a>4.2.2 编译应用程序</h3><p>编译应用程序不需要内核文件参与，只有一个文件就能编译，因此直接输入指令进行编译：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc chrdevbaseApp.c -o chrdevbaseApp</span><br></pre></td></tr></table></figure>

<p>编译会生chrdevbaseApp，它是32位LSB格式的ARM版本可执行文件</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/7.png"></p>
<h2 id="4-3-测试"><a href="#4-3-测试" class="headerlink" title="4.3 测试"></a>4.3 测试</h2><p>上一篇文章（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/400482593">i.MX6ULL嵌入式Linux开发6-系统烧写到eMMC与遇到的坑！</a>）已经实现了系统移植的打包烧录工作，系统已经烧录的EMMC中了。这次我们就直接在这个基础上进行实验。</p>
<h3 id="4-3-1-创建驱动模块目录"><a href="#4-3-1-创建驱动模块目录" class="headerlink" title="4.3.1 创建驱动模块目录"></a>4.3.1 创建驱动模块目录</h3><p>加载驱动模块，使用的modprobe命令，会从特定的目录下寻找文件。比如开发板使用的是4.1.15版的Linux内核 ，则是“/lib/modules/4.1.15”这个目录，这个目录一般是没有的，需要根据Linux内核的版本自己创建。</p>
<p>注意这是开发板的文件系统中的路径，可以通过串口连接进入开发板，通过linux指令创建该目录。</p>
<h3 id="4-3-2-发送文件到开发板-TFTP传输"><a href="#4-3-2-发送文件到开发板-TFTP传输" class="headerlink" title="4.3.2 发送文件到开发板(TFTP传输)"></a>4.3.2 发送文件到开发板(TFTP传输)</h3><p>此次测试首先需要<strong>将ubuntu中编译的文件传输到板子</strong>中运行，怎么传输呢？可以使用<strong>TFTP</strong>传输服务。</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/8.png"></p>
<p>在<strong>之前的文章</strong>（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/391215624">i.MX6ULL嵌入式Linux开发2-uboot移植实践</a>）中已经介绍了如何<strong>在ubuntu中搭建TFTP服务器</strong>。</p>
<p>搭建好TFTP服务后，开始传输文件到开发板具体的传输步骤为：</p>
<ul>
<li><p>开发板连接网线，与ubuntu虚拟机处于同一局域网内</p>
</li>
<li><p>确保ubuntu已安装的TFTP服务，并设置了TFTP服务文件夹</p>
</li>
<li><p>将ubuntu中编译好的文件<strong>复制到ubuntu的TFTP服务文件夹中</strong>！！！</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv chrdevbaseApp ~/myTest/tftpboot/</span><br><span class="line">mv chrdevbase.ko ~/myTest/tftpboot/</span><br></pre></td></tr></table></figure>

<p>注：编译完程序，在传输到板子之前，一定要记得把文件先复制到TFTP文件夹中，否则板子获取到的可能是TFTP文件夹中的旧文件。</p>
</li>
<li><p>开发板的<strong>串口中通过如下指令</strong>来将ubuntu中的文件传输到开发板中</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /lib/modules/4.1.15   /*确保在要下载文件的目录中，若已在，则忽略*/</span><br><span class="line">tftp -g -r chrdevbaseApp 192.168.5.101 /*获取chrdevbaseApp文件*/</span><br><span class="line">tftp -g -r chrdevbase.ko 192.168.5.101 /*获取chrdevbase.ko文件*/</span><br></pre></td></tr></table></figure>

<p>这里的<code>-g</code>代表get，即<strong>下载</strong>文件，<code>-r</code>代表remote file，即<strong>远程主机</strong>的文件名，然后是<strong>要下载的文件名</strong>，最后的远程主机ubuntu的<strong>IP地址</strong>。</p>
<p>输入该指令后，可以看到文件传输进度，如下图：</p>
</li>
</ul>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/9.png"></p>
<h3 id="4-3-3-开始测试"><a href="#4-3-3-开始测试" class="headerlink" title="4.3.3 开始测试"></a>4.3.3 开始测试</h3><p>驱动文件chrdevbase.ko和应用文件chrdevbaseApp传输到板子中的/lib/modules/4.1.15目录后，就可以测试了。</p>
<p>首先使用<code>insmod</code>命令来加载驱动，然后使用<code>lsmod</code>查看当前的驱动（只有一个我们刚加载的字符驱动），再使用使用<code>cat</code>指令查看devices 信息，确认系统中是否已经列举了该设备，3条指令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insmod chrdevbase.ko </span><br><span class="line">lsmod</span><br><span class="line">cat /proc/devices </span><br></pre></td></tr></table></figure>

<p>具体是输出信息：</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/10.png"></p>
<p>可以看出，系统中存在chrdevbase设备，主设备号为程序中设定的200。</p>
<p>驱动加载后，还要在/dev目录下<strong>创建一个对应的设备节点文件</strong>（应用程序就是通过该节点文件实现对设备的操作）。</p>
<p>输入如下2条命令创建/dev/chrdevbase这个设备节点文件，并查看结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mknod /dev/chrdevbase c 200 0 </span><br><span class="line">ls /dev/chrdevbase -l</span><br></pre></td></tr></table></figure>

<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/11.png"></p>
<p>至此，<strong>字符设备驱动已经加载完成</strong>，可以测试我们的应用程序了，也就是<strong>读</strong>和<strong>写</strong>：</p>
<p>按照上面程序的设定，1是读，2是写：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./chrdevbaseApp /dev/chrdevbase 1  </span><br><span class="line">./chrdevbaseApp /dev/chrdevbase 2</span><br></pre></td></tr></table></figure>

<ul>
<li>先来看“读测试”，注意要给chrdevbaseApp可执行的权限，否则无法运行。</li>
</ul>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/12.png"></p>
<p>图中下部是程序输出信息，但似乎只有BSP驱动程序的的输出，没有APP应用程序的输出，应该是内核打印printk与应用的打印printf冲突了，导致APP的打印被挤掉了。</p>
<ul>
<li>再来看“写测试’’，同样也是只有BSP的打印</li>
</ul>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/13.png"></p>
<h3 id="4-3-4-打印冲突问题规避"><a href="#4-3-4-打印冲突问题规避" class="headerlink" title="4.3.4 打印冲突问题规避"></a>4.3.4 打印冲突问题规避</h3><p>对于打印冲突问题，我们可以先在每个printf前后加个sleep(1)的1秒延时，这样可以先避免打印冲突。</p>
<p>增加延时后再次测试，打印正常：</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/14.png"></p>
<p>测试完，最后是rmmod命令卸载模块：</p>
<p><img src="https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/pic2/imx6u/7-chrbase/15.png"></p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>本篇介绍了嵌入式Linux驱动开发中的基础驱动——字符驱动开发的基本模式，使用了一个虚拟的字符设备驱动进行测试，了解驱动程序与应用程序之间的调用关系。</p>
</article><div><div style="text-align:center;color: #ccc;font-size:14px;font-family: cursive;">-------------&#x7EB8;&#x77ED;&#x60C5;&#x957F; <i class="fa fa-umbrella"></i> &#x4E0B;&#x6B21;&#x518D;&#x89C1;-------------</div></div><div id="wechat_subscriber"><center><img id="wechat_subscriber_qcode" src="undefined" onerror="onerror=null;src='https://xxpcb-1259761082.cos.ap-shanghai.myqcloud.com/hexo/wxgzh.png'" alt="码农爱学习"></center><div>关注微信公众号，获取更多精彩~</div></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xxpcb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xxpcb.gitee.io/2021/08/26/%E3%80%90i-MX6ULL%E3%80%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%911-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/">http://xxpcb.gitee.io/2021/08/26/%E3%80%90i-MX6ULL%E3%80%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%911-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xxpcb.gitee.io" target="_blank">码农爱学习的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/ARM/">ARM</a><a class="post-meta__tags" href="/tags/%E9%A9%B1%E5%8A%A8/">驱动</a></div><div class="post_share"><div class="social-share" data-image="/../img/imx/bsp1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/04/%E3%80%90i-MX6ULL%E3%80%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%912-%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/"><img class="prev-cover" src="/../img/imx/bsp2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【i.MX6ULL】驱动开发2--新字符设备开发模板</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/26/i-MX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%916-%E7%B3%BB%E7%BB%9F%E7%83%A7%E5%86%99%E5%88%B0eMMC%E4%B8%8E%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%EF%BC%81/"><img class="next-cover" src="/../img/imx/adapt6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">i.MX6ULL嵌入式Linux开发6-系统烧写到eMMC与遇到的坑！</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/09/04/【i-MX6ULL】驱动开发2-新字符设备开发模板/" title="【i.MX6ULL】驱动开发2--新字符设备开发模板"><img class="cover" src="/../img/imx/bsp2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-04</div><div class="title">【i.MX6ULL】驱动开发2--新字符设备开发模板</div></div></a></div><div><a href="/2021/08/26/i-MX6ULL嵌入式Linux开发3-Kernel移植/" title="i.MX6ULL嵌入式Linux开发3-Kernel移植"><img class="cover" src="/../img/imx/adapt3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-26</div><div class="title">i.MX6ULL嵌入式Linux开发3-Kernel移植</div></div></a></div><div><a href="/2021/08/26/i-MX6ULL嵌入式Linux开发5-根文件系统完善/" title="i.MX6ULL嵌入式Linux开发5-根文件系统完善"><img class="cover" src="/../img/imx/adapt5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-26</div><div class="title">i.MX6ULL嵌入式Linux开发5-根文件系统完善</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xxpcb</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/xxpcb"><i class="fab fa-github"></i><span>Follow Me (gitee)</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxpcb" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">分享：单片机、嵌入式、ARM、Linux、C/C++、python等技术文章~ <img src="/img/wxgzh-card.png"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Linux%E9%A9%B1%E5%8A%A8%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">1 Linux驱动分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Linux%E9%A9%B1%E5%8A%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">2 Linux驱动基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Linux%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Linux软件分层结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Linux内核驱动操作函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Linux%E9%A9%B1%E5%8A%A8%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Linux驱动运行方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Linux%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Linux设备号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E8%AE%BE%E5%A4%87%E5%8F%B7%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 设备号的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E4%B8%BB%E8%AE%BE%E5%A4%87%E5%8F%B7%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 主设备号的分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.</span> <span class="toc-text">3 字符设备驱动开发模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 加载与卸载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B3%A8%E9%94%80"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 注册与注销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%AE%9E%E7%8E%B0%E8%AE%BE%E5%A4%87%E7%9A%84%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 实现设备的具体操作函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%B7%BB%E5%8A%A0LICENSE%E5%92%8C%E4%BD%9C%E8%80%85%E4%BF%A1%E6%81%AF"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 添加LICENSE和作者信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C"><span class="toc-number">4.</span> <span class="toc-text">4 字符设备驱动开发实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 程序编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E7%BC%96%E5%86%99%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 编写驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E7%BC%96%E5%86%99%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 编写应用程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 程序编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E7%BC%96%E8%AF%91%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 编译驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E7%BC%96%E8%AF%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 编译应用程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%B5%8B%E8%AF%95"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%88%9B%E5%BB%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E7%9B%AE%E5%BD%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 创建驱动模块目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E5%88%B0%E5%BC%80%E5%8F%91%E6%9D%BF-TFTP%E4%BC%A0%E8%BE%93"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2 发送文件到开发板(TFTP传输)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E5%BC%80%E5%A7%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3 开始测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-%E6%89%93%E5%8D%B0%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%84%E9%81%BF"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4 打印冲突问题规避</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">5 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/04/%E3%80%90i-MX6ULL%E3%80%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%912-%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/" title="【i.MX6ULL】驱动开发2--新字符设备开发模板"><img src="/../img/imx/bsp2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【i.MX6ULL】驱动开发2--新字符设备开发模板"/></a><div class="content"><a class="title" href="/2021/09/04/%E3%80%90i-MX6ULL%E3%80%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%912-%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/" title="【i.MX6ULL】驱动开发2--新字符设备开发模板">【i.MX6ULL】驱动开发2--新字符设备开发模板</a><time datetime="2021-09-04T11:05:05.000Z" title="发表于 2021-09-04 19:05:05">2021-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/26/%E3%80%90i-MX6ULL%E3%80%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%911-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/" title="【i.MX6ULL】驱动开发1--字符设备开发模板"><img src="/../img/imx/bsp1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【i.MX6ULL】驱动开发1--字符设备开发模板"/></a><div class="content"><a class="title" href="/2021/08/26/%E3%80%90i-MX6ULL%E3%80%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%911-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/" title="【i.MX6ULL】驱动开发1--字符设备开发模板">【i.MX6ULL】驱动开发1--字符设备开发模板</a><time datetime="2021-08-25T16:06:15.000Z" title="发表于 2021-08-26 00:06:15">2021-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/26/i-MX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%916-%E7%B3%BB%E7%BB%9F%E7%83%A7%E5%86%99%E5%88%B0eMMC%E4%B8%8E%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%EF%BC%81/" title="i.MX6ULL嵌入式Linux开发6-系统烧写到eMMC与遇到的坑！"><img src="/../img/imx/adapt6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="i.MX6ULL嵌入式Linux开发6-系统烧写到eMMC与遇到的坑！"/></a><div class="content"><a class="title" href="/2021/08/26/i-MX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%916-%E7%B3%BB%E7%BB%9F%E7%83%A7%E5%86%99%E5%88%B0eMMC%E4%B8%8E%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%EF%BC%81/" title="i.MX6ULL嵌入式Linux开发6-系统烧写到eMMC与遇到的坑！">i.MX6ULL嵌入式Linux开发6-系统烧写到eMMC与遇到的坑！</a><time datetime="2021-08-25T16:05:57.000Z" title="发表于 2021-08-26 00:05:57">2021-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/26/i-MX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%915-%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%8C%E5%96%84/" title="i.MX6ULL嵌入式Linux开发5-根文件系统完善"><img src="/../img/imx/adapt5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="i.MX6ULL嵌入式Linux开发5-根文件系统完善"/></a><div class="content"><a class="title" href="/2021/08/26/i-MX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%915-%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%8C%E5%96%84/" title="i.MX6ULL嵌入式Linux开发5-根文件系统完善">i.MX6ULL嵌入式Linux开发5-根文件系统完善</a><time datetime="2021-08-25T16:05:46.000Z" title="发表于 2021-08-26 00:05:46">2021-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/26/i-MX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%914-%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" title="i.MX6ULL嵌入式Linux开发4-根文件系统构建"><img src="/../img/imx/adapt4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="i.MX6ULL嵌入式Linux开发4-根文件系统构建"/></a><div class="content"><a class="title" href="/2021/08/26/i-MX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%914-%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" title="i.MX6ULL嵌入式Linux开发4-根文件系统构建">i.MX6ULL嵌入式Linux开发4-根文件系统构建</a><time datetime="2021-08-25T16:05:35.000Z" title="发表于 2021-08-26 00:05:35">2021-08-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/../img/imx/bsp1.png')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By xxpcb</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'P6iS1Ip0yj2xKyDmnnT8mMrk-gzGzoHsz',
      appKey: 'bHIkuKIeQSpeQgKoE3vtEYKs',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>